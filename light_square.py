import sys
from numpy import matrix

def main(total_states = 2, start_state = [0,1,0,1,1,1,0,1,0]):
    moves = [   #the first tuple element specifies the button press
                #while the second element specifies the matrix change
                (1, matrix( [1, 1, 0, 1, 1, 0, 0, 0, 0] ) ),
                (2, matrix( [1, 1, 1, 0, 0, 0, 0, 0, 0] ) ),
                (3, matrix( [0, 1, 1, 0, 1, 1, 0, 0, 0] ) ),
                (4, matrix( [1, 0, 0, 1, 0, 0, 1, 0, 0] ) ),
                (5, matrix( [1, 1, 0, 1, 1, 1, 0, 1, 0] ) ),
                (6, matrix( [0, 0, 1, 0, 0, 1, 0, 0, 1] ) ),
                (7, matrix( [0, 0, 0, 1, 1, 0, 1, 1, 0] ) ),
                (8, matrix( [0, 0, 0, 0, 0, 0, 1, 1, 1] ) ),
                (9, matrix( [0, 0, 0, 0, 1, 1, 0, 1, 1] ) ),
            ]

    end_state = [0,0,0,0,0,0,0,0,0]
    #a list where newly created patterns reside, the first item of the inner
    #element is the list of button combinations, in order, and the second item
    #is the resulting state.  There are two main sections, one for new patterns
    #generated by the start_state, and one for patterns generated by the end_state
    init_patterns = [ [ ( [], matrix(start_state) ) ] , [ ( [], matrix(end_state) ) ] ]

    #the storage is where patterns may be stored after they have generated new patterns
    #and also where a pattern cross-checks for existing patterns before generating
    #new patterns.  There are two main sections, the first is for resulting patterns
    #from the end_state, and the second is for resulting patterns from the start_state
    storage = [ [], [] ]
    answer_found = False
    remaining_pattern = True
    combo_results = []

    while not answer_found:
        #loop through start and ending pattern sets individually
        for i,group in enumerate(init_patterns):
            if not answer_found:

                #check if the group has any patterns to evaluate
                if len(group) == 0:
                    remaining_pattern = False
                    continue
                else:
                    remaining_pattern = True
                    current_pattern = group[0]

                    #check if current pattern can be found
                    for pattern in storage[i]:
                        if (current_pattern[1] == pattern[1]).all():
                            answer_found = True
                            #we want to put the current pattern's button combos first if
                            #it is from the starting state's group
                            if i == 0:
                                combo_results.append(current_pattern[0] + pattern[0])
                            else:
                                combo_results.append(pattern[0] + current_pattern[0])
                            
                            break
                            
                    if answer_found:
                        #if so, then we have a winner!
                        #print the matched results
                        print 'Matching pattern was:', current_pattern[1]

                        #print out the moves
                        print 'The moves and their results were:\n'
                        for each_btn in combo_results:
                            print 'Move: ', each_btn
                            move_found = None
                            for each_move in moves:
                                if each_move[0] == each_btn:
                                    move_found = each_move[1]
                                    break
                            start_state = start_state + move_found
                            print start_state
                    else:
                        #create new patterns
                        for each_move in moves:
                            #get the next new pattern
                            new_pattern = current_pattern[1] + each_move[1]
                            #check if the pattern already exists in the unevaluated pattern group
                            if not any((new_pattern == pattern[1]).all() for pattern in group):
                                #check if the pattern already exists in the previously created patterns in storage
                                if not any((new_pattern == pattern[1]).all() for pattern in storage[(i + 1) % 2]):
                                    old_btn_combo = list(current_pattern[0])
                                    group.append(
                                                    (
                                                        old_btn_combo.append(each_move[0]),
                                                        new_pattern
                                                    )
                                                )

                        #move the current pattern to the opposite storage index for later checking
                        storage[(i + 1) % 2].append(current_pattern)
                        group.remove(current_pattern)

if __name__ == '__main__':
    if len(sys.argv) > 1:
        if int(sys.argv[1]) > 0:
            main(sys.argv[1])
        elif sys.argv[1] == '-d':
            main()
        else:
            print 'Did not recognize the data you specified.'
    else:
        total_states = int(raw_input('Please choose the maximum number of states: '))
        start_state = []
        
        for i in range(3):
            for j in range(3):
                mesg = 'Please input the matrix elements for row ', i, 'column ', j, ': '
                tmp = raw_input(mesg)
                start_state.append(int(tmp) % total_states)

        main(total_states, start_state)
